#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     color,          sensorCOLORFULL)
#pragma config(Sensor, S4,     HTPB,           sensorI2CCustom9V)
#pragma config(Motor,  motorA,          sense,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          back,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     grab,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    bucket,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo6,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servo5,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "battery.h"
//encoder values for tubes
const int LOW=-3690;
const int MID=-5705;
const int HIGH=-7700;
const int CENTER=0;
const int RAMPPOWER=50;
const int LINEPOWER=50;
const int RAMPTHRESH=28; //TODO GET THIS
volatile float theta=0;
int startingpos=0;

ubyte calibrate=0b00100000;
ubyte CLR=0b00010000;
ubyte turning=0b000001000;
ubyte doneTurning=0b00000100;
ubyte offRamp=0b00000010;
//ubyte haveTube=0b00000001;




void downRamp();
void dump();
void drive(int pwr);
void forwardToTube();
void forwardToLine();
void bringTubeBack();
void backToZone();
void findStand();
void rotateLeft(int degrees, int pwr);
void rotateRight(int degrees, int pwr);
task gyroThread();
void forwardToTube2();

int stationaryVoltage=514;
const float valueDegreeSecond=1.449/2;//for gyro analog conversion...//changed from 1.449 to 1.446: previous value would cause it to be off by .6 degrees/second/second
int STARTINGPOS=0;//0 for zone, 1 for ramp
int setup=1;//1- stand toward park, 2- stand at 45, 3-stand toward ramp
void init(){
	HTSPBsetupIO(HTPB,0b11000000);
	//light up for battery
	batteryUpdate(HTPB);
	servo[bucket]=120;

	ubyte in=HTSPBreadIO(HTPB,0b00001111);//get autonomous settings!
	bDisplayDiagnostics=false;
	nMotorEncoder[back]=0;
	nMotorEncoder[grab]=0;
	nMotorEncoder[motorC]=0;
	int sum=0;
			for(int i=0;i<5;i++){
					sum+=readAnalogInput(HTPB,1);
					wait1Msec(100);
			}
			stationaryVoltage=sum/5;
			while(nNxtButtonPressed!=3){
				if(HTSPBreadIO(HTPB,0b00000100)>0)STARTINGPOS=1;
				nxtDisplayCenteredBigTextLine(4,"%d",STARTINGPOS);
		}
		nxtDisplayCenteredBigTextLine(0,"WAITING");

}
task graph(){
	while(true){
		nxtDisplayCenteredBigTextLine(0,"%d",theta);
		nxtDisplayCenteredBigTextLine(3,"%d",HTSPBreadIO(HTPB,0b00000010));
		wait1Msec(100);
	}
}
bool hasTube(){
	bool have=false;
	if(HTSPBreadIO(HTPB,0b00000010)>=1){
			have=false;
		}
	else{
			if(HTSPBreadIO(HTPB,0b00000010)==0)have=true;
	}
	return have;
}
void backToZone(){
	rotateRight(25,50);
	motor[back]=-25;
	drive(-50);
	while(nMotorEncoder[back]>-30);
	motor[back]=0;
	while(nMotorEncoder[back]<-20);
	drive(50);
	wait1Msec(200);
	drive(0);
}
volatile int grabState=-1;//0 out 1= in
task grabber(){
	while(true){
		nxtDisplayCenteredBigTextLine(6,"%d",nMotorEncoder[grab]);
		if(grabState==0){
			if(nMotorEncoder[grab]<170*4)motor[grab]=15;
			else motor[grab]=0;
		}
		if(grabState==1){
			if(nMotorEncoder[grab]>80*4)motor[grab]=-15;
			else if(nMotorEncoder[grab]>20*4)motor[grab]=-12;
			else motor[grab]=0;
		}
		if(grabState==2){
				if(nMotorEncoder[grab]<80*4)motor[grab]=10;
			else motor[grab]=0;
		}
	}
}


task main()
{
	bDisplayDiagnostics=false;
	nMotorEncoder[sense]=0;
	/*
	motor[sense]=5;
	while(SensorValue[ir]!=5);
	motor[sense]=0;
	nxtDisplayCenteredBigTextLine(0,"%d",nMotorEncoder[sense]);
	motor[sense]=-5;
	while(nMotorEncoder[sense]>0);
	motor[sense]=0;
	wait1Msec(100000);
	StopAllTasks();
	*/

	init();
	theta=0;
	//downRamp();
	waitForStart();
	//wait1Msec(13000);
	StartTask(gyroThread);
	StartTask(graph);
	StartTask(grabber);
	//wait1msec(2000);
	//servo[bucket]=160;
//wait1Msec(100000);
	/*
forwardToLine();
	rotateLeft(20,20);
	drive(0);
	wait1Msec(250);
//	forwardToTube();
*/
//	servo[grab]=210;

//	wait1Msec(200);
//	bringTubeBack();


//servo[grab]=255;
//wait1Msec(1000);
//drive(50);
//wait1msec(2500);
if(STARTINGPOS==0){
	drive(0);
	grabState=2;
	forwardToTube2();
	bringTubeBack();
	wait1Msec(1000);
	//dump();
}
else{
	grabState=1;
	drive(50);
	wait1Msec(2000);
	drive(30);
	grabState=0;
	wait1Msec(1000);
	forwardToTube2();
	backToZone();
}
//backToZone();
//		while(true)readAnalogInput(HTPB,0);//before edge
	//downRamp();
	//clearTimer(T1);
	/*
	motor[claw]=50;
	wait1Msec(250);
	motor[claw]=5;
	motor[right]=50;
	motor[left]=0;
	wait1Msec(1000);
	motor[left]=-50;
	wait1Msec(8000);
	drive(0);*/
	while(true);
}
void dump(){
	servo[bucket]=180;
}
void forwardToLine(){
		while(SensorValue[color]==1){
		drive(LINEPOWER);
	}
	while(SensorValue[color]!=1){
		drive(LINEPOWER);
	}
	while(SensorValue[color]==1){
		drive(LINEPOWER);
	}
	drive(0);
}

//TODO, when encoder gets down to 90 deg (90*4), move forward.
void forwardToTube(){
	drive(50);
	wait1Msec(200);
	ClearTimer(T3);
	while(!hasTube());
	drive(0);
	grabState=1;
}
void forwardToTube2(){
	if(STARTINGPOS==0){
		motor[motorC]=-25;
		while(nMotorEncoder[motorC]>-165);
		motor[motorC]=0;
}
	drive(30);
	wait1Msec(200);
	ClearTimer(T3);
	int pwr=30;
	bool b=false;
	while(!hasTube()&& (b=nMotorEncoder[motorC]>-190)){
		if(time1[T3]>2400)grabState=0;
		if(time1[T3]>3100)drive(10);
		if(nMotorEncoder[motorC]<160)motor[motorC]=0;
		else motor[motorC]=1;
	}if(STARTINGPOS==0){
	ClearTimer(T3);
		drive(-50);
		wait1Msec(25);
		drive(0);
		grabState=1;
		drive(-6);
		while(nMotorEncoder[grab]>80*4&&time1[T3]<3000);
		drive(25);
		wait1Msec(400);
	}
	else{
			grabState=1;
			wait1Msec(2000);
		}
	drive(0);
	if(STARTINGPOS==0){
		wait1Msec(250);
		dump();
		wait1Msec(500);
}
	motor[motorC]=0;
}
void bringTubeBack(){
	motor[back]=-25;
	drive(-50);
	while(nMotorEncoder[back]>-30);
	motor[back]=0;
	while(nMotorEncoder[back]<-20);
	drive(50);
	wait1Msec(300);
	drive(0);
	//wait1Msec(500);
	//dump();
	//wait1Msec(1000);
	rotateRight(60,35);
	drive(0);
	wait1msec(100);
	drive(-75);
	wait1Msec(500);
	drive(10);
	wait1Msec(50);
	drive(0);
	grabState=0;
}
//0 for stop
void drive(int pwr){
	motor[right]=-pwr;
	motor[left]=pwr;
}
void turn(int deg, int pwr){

}
void rotateRight(int degrees, int pwr){
		float itheta=theta;
		hi:
		motor[left]=pwr;
		motor[right]=pwr;
		while(theta-itheta<degrees-10);
		motor[left]=0;
		motor[right]=0;
		wait1Msec(200);
	//	if(theta-itheta<degrees)goto hi;
		motor[left]=-20;
		motor[right]=-20;
		while(theta-itheta>degrees);
		motor[left]=0;
		motor[right]=0;
}
void rotateLeft(int degrees, int pwr){
		float itheta=theta;
		hi:
		motor[left]=-pwr;
		motor[right]=-pwr;
		while(itheta-theta<degrees-10);
		motor[left]=0;
		motor[right]=0;
		wait1Msec(200);
		//if(itheta-theta<degrees)goto hi;
		motor[left]=20;
		motor[right]=20;
		while(itheta-theta>degrees);
		motor[left]=0;
		motor[right]=0;
}
task gyroThread(){
		//StartTask(graphicsThread);
		ClearTimer(T4);
		while(true){
				int v=0;

				v=readAnalogInput(HTPB,1);
		//		sonar1=readAnalogInput(HTPB,1);
			/*	sonar1=readAnalogInput(HTPB,1);
				sonar2=readAnalogInput(HTPB,2);
				sonar3=readAnalogInput(HTPB,3);
			*/
				int gyrovolts=v;
				float dv=v-stationaryVoltage;
				float dtheta=dv*valueDegreeSecond;
				theta+=dtheta*time1[T4]*.001;
			//	updateTime=time1[T4];
				ClearTimer(T4);
				wait1Msec(2);
		}
}
