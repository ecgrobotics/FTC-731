#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     color,          sensorCOLORFULL)
#pragma config(Sensor, S4,     HTPB,           sensorI2CCustom9V)
#pragma config(Motor,  motorA,          sense,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          back,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     grab,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    ser,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    bucket,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo6,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    nope,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "battery.h"
//encoder values for tubes
const int LOW=-3690;
const int MID=-5705;
const int HIGH=-7700;
const int CENTER=0;
const int RAMPPOWER=50;
const int LINEPOWER=50;
const int RAMPTHRESH=28; //TODO GET THIS
const int turn30=0;
const int turn45=1;
const int turn60=2;
const int turn90=3;
const int turn120=4;
const int turn150=5;
const int turn180=6;
const int turnR=0b1000;
const int turnL=0b000;
int startingpos=0;

ubyte calibrate=0b00100000;
ubyte CLR=0b00010000;
ubyte turning=0b000001000;
ubyte doneTurning=0b00000100;
ubyte offRamp=0b00000010;
ubyte haveTube=0b00000001;
ubyte almost=1;



void downRamp();
void dump();
void drive(int pwr);
void forwardToTube();
void forwardToLine();
void bringTubeBack();
void backToZone();
void findStand();
void rotateRightLP(ubyte amount, int pw);
void rotateLeftLP(ubyte amount, int pw);
void forwardToTube2();
int delay=0;
int STARTINGPOS=0;//0 for zone, 1 for ramp
int setup=1;//1- stand toward park, 2- stand at 45, 3-stand toward ramp
ubyte io=0;

void writeIO(){
	HTSPBwriteIO(HTPB,io);
}

void calibrateGyro(){
	drive(0);
	io=io|calibrate;
	writeIO();
	wait1Msec(100);
	io=io& ~calibrate;
	writeIO();
	wait1Msec(100);
}
void reset(){
	io=io|CLR;
	writeIO();
	wait1Msec(10);
	io=io & ~CLR;
	writeIO();
}
void init(){//**********************************INIT******************
	HTSPBsetupIO(HTPB,0b00111000);//0 in 1 out
	//light up for battery
	servo[bucket]=120;

	ubyte in=HTSPBreadIO(HTPB,0b00001111);//get autonomous settings!
	bDisplayDiagnostics=false;
	nMotorEncoder[back]=0;
	nMotorEncoder[grab]=0;
	nMotorEncoder[motorC]=0;
	ClearTimer(T4);
	HTSPBwriteIO(HTPB,turning);
	while(nNxtButtonPressed!=3){
				if(HTSPBreadIO(HTPB,0b01000000)>0)STARTINGPOS=1;
				else STARTINGPOS=0;
				delay=(int)(30000.0*((float)readAnalogInput(HTPB,0)/1023.0));
				nxtDisplayCenteredBigTextLine(0,"WAITING!");
				nxtDisplayCenteredBigTextLine(2,"%d",HTSPBreadIO(HTPB,0b11111111));
				nxtDisplayCenteredBigTextLine(4,"%d",STARTINGPOS);
				nxtDisplayCenteredBigTextLine(6,"%d",delay);
				HTSPBwriteAnalog(HTPB,HTSPB_DACO0,DAC_MODE_SQUAREWAVE,1,620);
		}
		HTSPBwriteAnalog(HTPB,HTSPB_DACO0,DAC_MODE_DCOUT,1,0);
		eraseDisplay();
		nxtDisplayCenteredBigTextLine(0,"READY!");
		calibrateGyro();
		reset();
}
task graph(){
	while(true){
		nxtDisplayCenteredBigTextLine(0,"%d",HTSPBreadIO(HTPB,doneTurning));
		nxtDisplayCenteredBigTextLine(3,"%d",HTSPBreadIO(HTPB,haveTube));
		wait1Msec(100);
	}
}
bool hasTube(){
	bool have=true;
	if(HTSPBreadADC(HTPB,2,10)>=600){
			have=true;
		}
	else{
		have=false;
		//	if(HTSPBreadIO(HTPB,haveTube)==0)have=false;
	}
	return have;
}
void backToZone(){
	rotateRightLP(25,turn45);
	motor[back]=-25;
	drive(-50);
	while(nMotorEncoder[back]>-30);
	motor[back]=0;
	while(nMotorEncoder[back]<-20);
	drive(50);
	wait1Msec(200);
	drive(0);
}
volatile int grabState=-1;//0 out 1= in

task grabber(){
	while(true){
		nxtDisplayCenteredBigTextLine(6,"%d",nMotorEncoder[grab]);
		if(grabState==0){
			if(nMotorEncoder[grab]<170*4)motor[grab]=15;
			else motor[grab]=0;
		}
		if(grabState==1){
			if(nMotorEncoder[grab]>80*4)motor[grab]=-15;
			else if(nMotorEncoder[grab]>20*4)motor[grab]=-12;
			else motor[grab]=0;
		}
		if(grabState==2){
				if(nMotorEncoder[grab]<80*4)motor[grab]=10;
			else motor[grab]=0;
		}
	}
}


task main()
{
	bDisplayDiagnostics=false;
	nMotorEncoder[sense]=0;
	init();


	//downRamp();
	waitForStart();
	wait1Msec(delay);
	//wait1Msec(13000);
	StartTask(graph);
	//wait1Msec(10000);
	//reset();
	/*
	rotateRightLP(turn90,30);
	wait1Msec(5000);
	reset();
	calibrateGyro();
	wait1Msec(10);
	rotateLeftLP(turn90,30);

	*/
	//rotateRightLP(turn90,30);
//	StopAllTasks();

	//while(true);

	StartTask(grabber);
	if(STARTINGPOS==0){
		drive(0);
		grabState=2;
		forwardToTube2();
		bringTubeBack();
		wait1Msec(1000);
		//dump();
	}
	else{
		grabState=1;
		drive(50);
		wait1Msec(2000);
		drive(30);
		grabState=0;
		wait1Msec(1000);
		forwardToTube2();
		backToZone();
	}
	while(true);
}
void rotateRightLP(ubyte amount, int pw){
	setStrobe(HTPB,turnR | amount);
	io=io|turning;
	writeIO();
	motor[left]=pw;
	motor[right]=pw;
	while(HTSPBreadADC(HTPB,almost,10)<600);
	motor[left]=20;
	motor[right]=20;
	while(!HTSPBreadIO(HTPB,doneTurning));
	drive(0);
	io=io& ~turning;
	io=io|doneTurning;
	writeIO();
}
void rotateLeftLP(ubyte amount, int pw){
	setStrobe(HTPB,turnL | amount);
	io=io|turning;
	writeIO();
	motor[left]=-pw;
	motor[right]=-pw;
	while(HTSPBreadADC(HTPB,almost,10)<600);
	motor[left]=-20;
	motor[right]=-20;
	while(!HTSPBreadIO(HTPB,doneTurning));
	drive(0);
	io=io& ~turning;

	io=io|doneTurning;
	writeIO();
}
void dump(){
	servo[bucket]=180;
}
void forwardToLine(){
		while(SensorValue[color]==1){
		drive(LINEPOWER);
	}
	while(SensorValue[color]!=1){
		drive(LINEPOWER);
	}
	while(SensorValue[color]==1){
		drive(LINEPOWER);
	}
	drive(0);
}

//TODO, when encoder gets down to 90 deg (90*4), move forward.
void forwardToTube(){
	drive(50);
	wait1Msec(200);
	ClearTimer(T3);
	while(!hasTube());
	drive(0);
	grabState=1;
}
void forwardToTube2(){
	if(STARTINGPOS==0){
		motor[motorC]=-25;
		while(nMotorEncoder[motorC]>-165);
		motor[motorC]=0;
		}
	drive(30);
	wait1Msec(200);
	ClearTimer(T3);
	int pwr=30;
	bool b=false;
	top:
	while(!hasTube()&& (b=nMotorEncoder[motorC]>-190)){
			if(time1[T3]>2700)grabState=0;
			if(time1[T3]>3100)drive(10);
			if(nMotorEncoder[motorC]<160)motor[motorC]=0;
			else motor[motorC]=1;
	}
	if(time1[T3]<2500)goto top;
	if(STARTINGPOS==0){
				ClearTimer(T3);
				drive(-50);
				wait1Msec(25);
				drive(0);
				grabState=1;
				wait1Msec(500);
				drive(-15);
				wait1Msec(500);
				drive(15);
				while(!hasTube());
				drive(0);
			//	while(nMotorEncoder[grab]>80*4&&time1[T3]<3000);
			//	drive(25);
				wait1Msec(400);
	}
	else{
			grabState=1;
			wait1Msec(2000);
	}
	drive(0);
	if(STARTINGPOS==0){
		wait1Msec(250);
		dump();
		wait1Msec(500);
}
	motor[motorC]=0;
}
void bringTubeBack(){
	motor[back]=-25;
	drive(-50);
	while(nMotorEncoder[back]>-30);
	motor[back]=0;
	while(nMotorEncoder[back]<-20);
	drive(50);
	wait1Msec(300);
	drive(0);
	//wait1Msec(500);
	//dump();
	//wait1Msec(1000);
	rotateRightLP(turn60,35);
	drive(0);
	wait1msec(100);
	drive(-75);
	wait1Msec(500);
	drive(10);
	wait1Msec(50);
	drive(0);
	grabState=0;
}
//0 for stop
void drive(int pwr){
	motor[right]=-pwr;
	motor[left]=pwr;
}
