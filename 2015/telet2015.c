
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     color,          sensorCOLORFULL)
#pragma config(Sensor, S4,     HTPB,           sensorI2CCustom9V)
#pragma config(Motor,  motorA,          claw,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rear,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     grab,          tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     arm,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    bucket,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,           	    tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("joystickGame")
//#include "HTPB.h"
#include "JoystickDriver.c"
#include "battery.h";
int encoder=0;
int serv=0;
volatile bool havetube=false;
volatile int status=0;
volatile bool locked=false;
volatile int encLock=0;

const int encOffset=5;
float e=0;
	float de=0;
	float olde=0;
	int pid=0;
task input(){
	while(true){
			ubyte in=HTSPBreadIO(HTPB,0b00000010);
			int gyro=readAnalogInput(HTPB,1);
			int l=readAnalogInput(HTPB,0);
			//int acc=readAnalogInput(HTPB,0);
			//float z=readAnalogVolts(HTPB,0);

//			nxtDisplayCenteredBigTextLine(0,"%d",in);
	//		nxtDisplayCenteredBigTextLine(2,"%d",l);
		//	nxtDisplayCenteredBigTextLine(4,"%d",SensorValue[color]);
			nxtDisplayCenteredBigTextLine(0,"%d",nMotorEncoder[arm]);
			nxtDisplayCenteredBigTextLine(2,"%d",e);
			nxtDisplayCenteredBigTextLine(4,"%d",de);
			nxtDisplayCenteredBigTextLine(6,"%d",pid);


			wait1Msec(10);
			if(in>=1)havetube=true;//inverted
			else havetube=false;

			if(bDisconnected){
				status=1;
			}
			else if(externalBattery<0){
				status=2;
			}else status=0;
	}
}
const float KP=1;
const float KD=1;

task armControl(){
	ClearTimer(T2);
	while(true){
		olde=e;
		e=(nMotorEncoder[grab]/4.0)-(encLock/4.0);
		de=(e-olde)/(time1[T2]*.001);
		if(locked){
			if(nMotorEncoder[grab]>encLock){
				pid=(KP*e)+(KD*de);
				motor[grab]=-pid;//-(encOffset+nMotorEncoder[grab]-encLock);//motor power higher the furth out.
			}
			else motor[grab]=0;//encOffset?
		}
	}
}
void RSLon(){
	HTSPBwriteIO(HTPB,0b00000000);
	wait1Msec(5);
	HTSPBwriteIO(HTPB,0b00000000);
}
void RSLoff(){
	HTSPBwriteIO(HTPB,0b00010000);
	wait1Msec(5);
	HTSPBwriteIO(HTPB,0b00010000);
}
task RSL(){
	while(true){
		nxtDisplayCenteredBigTextLine(6,"%d",status);
		switch(status){
			case 0:
				RSLon();
				wait1Msec(250);
				RSLoff();
				wait1Msec(1500);
				break;
			case 1:
				RSLon();
				wait1Msec(1500);
				RSLoff();
				wait1Msec(250);
				break;
			case 2:
				RSLon();
				wait1Msec(100);
				RSLoff();
				wait1Msec(100);
				break;
		}
	}

}
int STARTINGPOS=0;//0 for zone, 1 for ramp
void init(){
		bDisplayDiagnostics=false;
	//	StartTask(batteryTask);

		HTSPBsetupIO(HTPB,0b11110000);
		batteryUpdate(HTPB);
		nMotorEncoder[grab]=0;
		servo[bucket]=81;

}
task main()
{

		init();
		float servoff=0;
		waitForStart();
		StartTask(RSL);
		StartTask(input);
		StartTask(armControl);
		while(true){
				getJoystickSettings(joystick);
				if(!(joy1Btn(8)==1&&joy1Btn(7)==1)){
					motor[left]=joystick.joy1_y1;
					motor[right]=-joystick.joy1_y2;
				}	else{
					motor[left]=joystick.joy1_y1/4;
					motor[right]=-joystick.joy1_y2/4;
				}
				if(joy1Btn(2)==1&&serv<255){
						serv+=1;
				}
				if(joy1Btn(4)==1&&serv>0){
						serv-=1;
				}
				if(joy1Btn(3)==1){
					locked=true;
					encLock=nMotorEncoder[grab];
				}
				if(joy1Btn(6)==1){motor[grab]=-15;locked=false;}
				else if(joy1Btn(5)==1){motor[grab]=15;locked=false;}
				else motor[grab]=0;

				if(joy1Btn(8)==1&&joy1Btn(7)!=1)motor[motorC]=-10;
				else if(joy1Btn(7)==1&&joy1Btn(8)!=1)motor[motorC]=10;
				else motor[motorC]=0;
				servo[bucket]=serv;
				int ap=joystick.joy2_y2;
				motor[arm]=abs(ap)>5?ap:0;
		}
}
